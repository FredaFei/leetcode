# 链表（linked list）

# 应用场景
> 经典的链表应用场景，那就是 LRU 缓存淘汰算法。常见的缓存有数据库缓存、浏览器缓存、cup缓存。

常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）

# 如何基于链表实现LRU缓存淘汰算法？
基于一个有序单链表，越靠近链表尾部的节点越是之前访问的

1. 假设此数据已被插入到缓存链表中了，遍历链表得到此数据对应的节点，并将其重原来的位置删除，然后插入到链表的头部
2. 如果此数据不在缓存链表中，则分为：
  + 若缓存未满，将此节点插入链表头部;
  + 若缓存已满，将链表尾部节点删除，将次节点插入链表头部

时间复杂度为O(n) 

# 如何基于数组实现LRU缓存淘汰算法？

数组是连续的内存空间，cpu从内存中读取数据时，读取的并非是特定的一个访问地址，而是一个数据块，并会把读取到的数据加载到cpu的缓存。下次访问内存数据优先从cpu缓存中开始查找，若是没有找到便会去内存中查找。也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。
